# Stage3 - Part3：GridWorld Classes and Interfaces

**郑有为 19335286**

[toc]

### Set 3

Assume the following statements when answering the following questions.

```
Location loc1 = new Location(4, 3);
Location loc2 = new Location(3, 4);
```

1. How would you access the row value for loc1?
   
   回答：通过以下代码：
   
   ```java
   loc1.getRow()
   ```
   
   原因：参考 Location 类提供的方法：
   
   ```java
   // @file: gridworld/Location.java
   // @line: 110-113
   
   public int getRow()
   {
       return row;
   }
   ```
2. What is the value of b after the following statement is executed?
   
   ```
   boolean b = loc1.equals(loc2);
   ```
   
   回答：false
   
   原因：参考 Location equals 方法：
   
   ```java
   // @file: gridworld/Location.java
   // @line: 211
   return getRow() == otherLoc.getRow() && getCol() == otherLoc.getCol();
   ```
3. What is the value of loc3 after the following statement is executed?
   
   ```
   Location loc3 = loc2.getAdjacentLocation(Location.SOUTH);
   ```
   
   回答：(4, 4)
   
   原因：SOUTH为向南，行数加一。
   
   ```java
   // @file: gridworld/Location.java
   // @line: 147-148
   else if (adjustedDirection == SOUTH)
   	dr = 1;
   
   // @file: gridworld/Location.java
   // @line: 168
   return new Location(getRow() + dr, getCol() + dc);
   ```
4. What is the value of dir after the following statement is executed?
   
   ```
   int dir = loc1.getDirectionToward(new Location(6, 5));
   ```
   
   回答：135（LOCATION.SOUTHEAST）
   
   原因：原来为坐标为 (4, 3)，现在为 (6, 5)，$(\Delta r,\Delta c) = (2,2)$，方向指向东南。
   
   ```java
   // @file: gridworld/Location.java
   // @line: 180-194
   int dx = target.getCol() - getCol();
   int dy = target.getRow() - getRow();
   // y axis points opposite to mathematical orientation
   int angle = (int) Math.toDegrees(Math.atan2(-dy, dx));
   
   // mathematical angle is counterclockwise from x-axis,
   // compass angle is clockwise from y-axis
   int compassAngle = RIGHT - angle;
   // prepare for truncating division by 45 degrees
   compassAngle += HALF_RIGHT / 2;
   // wrap negative angles
   if (compassAngle < 0)
       compassAngle += FULL_CIRCLE;
   // round to nearest multiple of 45
   return (compassAngle / HALF_RIGHT) * HALF_RIGHT;
   ```
5. How does the getAdjacentLocation method know which adjacent location to return?
   
   回答：getAdjacentLocation首先对处理角度，让后映射到方向上，最后根据方向对应的单位$(\Delta r,\Delta c)$来计算得到相邻位置。
   
   原因：
   
   ```java
   // @file: gridworld/Location.java
   // @line: 138-167
   // 根据方向获取 Delta r 和 Delat c
   
   // @file: gridworld/Location.java
   // @line: 168
   return new Location(getRow() + dr, getCol() + dc);
   ```

### Set 4

1. How can you obtain a count of the objects in a grid? How can you obtain a count of the empty locations in a bounded grid?
   
   回答：首先通过调用`getOccupiedLocations()`来获得一个Location的数组，该数组中每个Location为一个被占用的网格的位置，只需调用ArrayList内置函数`.count()`就可以获取网格中对象的数量。对于空位置个数，只需要用网格总个数减去已被占用的网格数即可得到结果，代码如下所示：
   
   ```java
   // 设当前网格对象为 grid
   int objectCount = grid.getOccupiedLocations().count();
   int emptyLocationCount = grid.getNumRows() * grid.getNumCols() - objectCount;
   ```
   
   解释：使用到的函数的函数如下。
   
   ```java
   // @file: gridworld/Grid.java
   // @line: 35, 41, 85
   int getNumRows();
   int getNumCols();
   ArrayList<Location> getOccupiedLocations();
   ```
2. How can you check if location (10,10) is in a grid?
   
   回答：首先创建一个Location实例，然后调用`isValid`函数
   
   ```java
   boolean res = grid.isValid(new Location(10,10));
   ```
   
   解释：使用到的函数如下。
   
   ```java
   // @file: gridworld/Grid.java
   // @line: 50
   boolean isValid(Location loc);
   ```
3. Grid contains method declarations, but no code is supplied in the methods. Why? Where can you find the implementations of these methods?
   
   回答：因为Grid是一个接口，需要具体的类来继承这个接口并实现这些方法。
   
   ```java
   // @file: gridworld/Grid.java
   // @line: 29
   public interface Grid<E>
   ```
   
   i抽象类 AbstractGrid实现了该接口，然后具体类 BoundedGrid 和 UnboundedGrid 继承了抽象类。抽象类实现了Grid的接口一部分方法，剩下的部分由具体类来实现。
   
   ```java
   // @file: gridworld/AbstractGrid.java
   // @line: 26
   public abstract class AbstractGrid<E> implements Grid<E>
   
   // @line: 28
   public ArrayList<E> getNeighbors(Location loc);
   
   // @line: 36
   public ArrayList<Location> getValidAdjacentLocations(Location loc);
   
   // @line: 51
   public ArrayList<Location> getEmptyAdjacentLocations(Location loc);
   
   // @line: 62
   public ArrayList<Location> getOccupiedAdjacentLocations(Location loc);
   ```
   
   ```java
   // @file: gridworld/BoundedGrid.java
   // @line: 29
   public class BoundedGrid<E> extends AbstractGrid<E>
   
   // @line: 48
   public int getNumRows();
   
   // @line: 53
   public int getNumCols();
   
   // @line: 60
   public boolean isValid(Location loc);
   
   // @line: 66
   public ArrayList<Location> getOccupiedLocations();
   
   // @line: 85
   public E get(Location loc);
   
   // @line: 93
   public E put(Location loc, E obj);
   
   // @line: 107
   public E remove(Location loc);
   ```
   
   ```java
   // @file: gridworld/UnboundedGrid.java
   // @line: 31
   public class UnboundedGrid<E> extends AbstractGrid<E>
   
   // @line: 43
   public int getNumRows();
   
   // @line: 48
   public int getNumCols();
   
   // @line: 53
   public boolean isValid(Location loc);
   
   // @line: 58
   public ArrayList<Location> getOccupiedLocations();
   
   // @line: 66
   public E get(Location loc);
   
   // @line: 73
   public E put(Location loc, E obj);
   
   // @line: 82
   public E remove(Location loc);
   ```
4. All methods that return multiple objects return them in an ArrayList. Do you think it would be a better design to return the objects in an array? Explain your answer.
   
   回答：No，因为 ArrayList 提供了更多内置的方法，方便使用者使用。例如ArrayList提供的`size()`函数，方便我们直接获取长度，可以直接使用`add()`或者`remove()`来插入或删除元素。除此之外，ArrayList的初始化、拷贝更为方便。因此使用普通数组代替 ArrayList 不见得是更好的选择。

### Set 5

1. Name three properties of every actor.
   
   回答：位置（location）、方向（direction）、颜色（color）
   
   解释：Actor类有以下三个属性
   
   ```java
   // @file: gridworld/actor/Actor.java
   // @line: 32-34
   private Location location;
   private int direction;
   private Color color;
   ```
2. When an actor is constructed, what is its direction and color?
   
   回答：方向：北（Location.NORTH），颜色：蓝色（Color.BLUE）
   
   解释：在 Actor 构造函数的代码中可以看到
   
   ```java
   // @file: gridworld/actor/Actor.java
   // @line: 41-42
   color = Color.BLUE;
   direction = Location.NORTH;
   ```
3. Why do you think that the Actor class was created as a class instead of an interface?
   
   回答：一个Actor除了有行为（Behaviour）外，还有属性（Attribute），并且这些属性是任意一种Actor都共有的；
   
   ```java
   // @file: gridworld/actor/Actor.java
   // @line: 32-34
   private Location location;
   private int direction;
   private Color color;
   ```
   
   同时不同的Actor有相同的行为，这些行为的实现是一致的，故可以使用一个基类的形式来提供这些方法，因此使用类而不是接口更合适。
4. Can an actor put itself into a grid twice without first removing itself? Can an actor remove itself from a grid twice? Can an actor be placed into a grid, remove itself, and then put itself back? Try it out. What happens?
   
   回答：
   
   * 一个Grid不能在没有移除自己的情况下两次将自己放入一个格子中，会报错
     
     ```java
     // @file: gridworld/actor/Actor.java
     // @line: 117-119
     if (grid != null)
         throw new IllegalStateException(
         "This actor is already contained in a grid.");
     ```
   * 一个Grid不能连续把自己从Grid中移除两次，第一次删除后使得`grid == null`
     
     ```java
     // @file: gridworld/actor/Actor.java
     // @line: 135-137
     if (grid == null)
         throw new IllegalStateException(
         "This actor is not contained in a grid.");
     ```
   * 一个Actor可以把自己放心一个格子中，然后移除，在将自己放回去。整个过程不会报错和产生异常。可以编写如下测例证明：
     
     ```java
     public class Test{
         public static void main(String[] args){
             ActorWorld world = new ActorWorld();
             Location location = new Location(5,5);
             Actor actor = new Actor();
             Grid grid = actor.getGrid();
     
             world.add(actor, location);
             world.show();
     
             actor.removeSelfFromGrid();
             actor.putSelfInGrid(grid, location);
         }
     }
     ```
5. How can an actor turn 90 degrees to the right?
   
   回答：通过设置actor的方向为当前方向 + Location.RIGHT
   
   ```java
   actor.setDirection(getDirection() + Location.RIGHT);
   ```
   
   解释：
   
   ```java
   // @file: gridworld/grid/Grid.java
   // @line: 40
   public static final int RIGHT = 90;
   ```

### Set 6

1. Which statement(s) in the canMove method ensures that a bug does not try to move out of its grid?
   
   回答： 如果下一步的位置是非法的（越界），`canMove()`将会返回 false
   
   ```java
   // @file: gridworld/actor/Bug.java
   // @line: 98-99
   if (!gr.isValid(next))
   	return false;
   ```
2. Which statement(s) in the canMove method determines that a bug will not walk into a rock?
   
   回答：只有当下一个位置是空的或者有 Flower时，`canMove()`才会返回 true，对于含 Rock 的一个位置，`canMove()`会返回 false
   
   ```java
   // @file: gridworld/actor/Bug.java
   // @line: 101
   return (neighbor == null) || (neighbor instanceof Flower);
   ```
3. Which methods of the Grid interface are invoked by the canMove method and why?
   
   回答：`isValid()`函数和`get()`函数，分别用于判断Bug的下一个微位置是否合法和获取Grid对应位置存放的Actor（可能为空）。
   
   ```java
   // @file: gridworld/actor/Bug.java
   // @line: 98
   if (!gr.isValid(next))
   // @line: 100
   Actor neighbor = gr.get(next);
   ```
4. Which method of the Location class is invoked by the canMove method and why?
   
   回答：`getAdjacentLocation()`函数，用于获取Bug按当前方向的下一步的位置。
   
   ```java
   // @file: gridworld/actor/Bug.java
   // @line: 97
   Location next = loc.getAdjacentLocation(getDirection());
   ```
5. Which methods inherited from the Actor class are invoked in the canMove method?
   
   回答：`getGrid()`函数、`getLocation()`函数和`getDirection()`函数
   
   ```java
   // @file: gridworld/actor/Bug.java
   // @line: 93
   Grid<Actor> gr = getGrid();
   
   // @line: 96
   Location loc = getLocation();
   
   // @line: 97
   Location next = loc.getAdjacentLocation(getDirection());
   ```
6. What happens in the move method when the location immediately in front of the bug is out of the grid?
   
   回答：Bug 会将自己从 Grid 中移除。
   
   ```java
   // @file: gridworld/actor/Bug.java
   // @line: 78-81
   if (gr.isValid(next))
       moveTo(next);
   else
       removeSelfFromGrid();
   ```
7. Is the variable loc needed in the move method, or could it be avoided by calling getLocation() multiple times?
   
   回答：Yes，`loc`记录了 Bug 在 Grid 移动之前的位置，它用于获取 Bug 下一个步移动到的位置，将 Bug 移除该格子并将一个 Flower 插入该格子。
   
   ```java
   // @file: gridworld/actor/Bug.java
   // @line: 77
   Location next = loc.getAdjacentLocation(getDirection());
   // @line: 83
   flower.putSelfInGrid(gr, loc);
   ```
   
   可以使用一个属性来记录，这样就不用每次都调用`getLocation()`来获取位置了。
8. Why do you think the flowers that are dropped by a bug have the same color as the bug?
   
   回答：因为在 Flower 创建时，指定了 Flower 的颜色为 Bug 当前的颜色。
   
   ```java
   // @file: gridworld/actor/Bug.java
   // @line: 82
   Flower flower = new Flower(getColor());
   ```
9. When a bug removes itself from the grid, will it place a flower into its previous location?
   
   回答：No，Bug只会在移动后放置一个 Flower 在原来的位置，直接移除不会放置 Flower。
   
   ```java
   // @file: gridworld/actor/Actor.java
   // @line: 143-145
   grid.remove(location);
   grid = null;
   location = null;
   ```
10. Which statement(s) in the move method places the flower into the grid at the bug’s previous location?
    
    回答：`flower.putSelfInGrid(gr, loc);`
    
    ```java
    // @file: gridworld/actor/Bug.java
    // @line: 82-83
    Flower flower = new Flower(getColor());
    flower.putSelfInGrid(gr, loc);
    ```
11. If a bug needs to turn 180 degrees, how many times should it call the turn method?
    
    回答：需要调用`turn()`四次，因为一次转动 45度，转动180度故需要180 / 45 = 4次
    
    ```java
    // @file: gridworld/grid/Location.java
    // @line: 48
    public static final int HALF_RIGHT = 45;
    
    // @file: gridworld/actor/Bug.java
    // @line: 64
    setDirection(getDirection() + Location.HALF_RIGHT);
    ```