# Stage 3 - Part 4 Interacting Objects

**郑有为 19335286**

### Set 7

The source code for the Critter class is in the critters directory

1. What methods are implemented in Critter?
   
   回答：实现的方法有：`act`、`getActors`、`processActors`、`getMoveLocations`、`selectMoveLocation`、`makeMove`
   
   ```java
   // @file: gridworld/actor/Critter.java
   // @line: 38
   public void act();
   
   // @line: 56
   public ArrayList<Actor> getActors();
   
   // @line: 71
   public void processActors(ArrayList<Actor> actors);
   
   // @line: 88
   public ArrayList<Location> getMoveLocations();
   
   // @line: 104
   public Location selectMoveLocation(ArrayList<Location> locs);
   
   // @line: 125
   public void makeMove(Location loc);
   ```
2. What are the five basic actions common to all critters when they act?
   
   回答：五个共同的动作是：`getActors`、`processActors`、`getMoveLocations`、`selectMoveLocation`、`makeMove`
   
   ```java
   // @file: gridworld/actor/Critter.java
   // @line: 56
   public ArrayList<Actor> getActors();
   
   // @line: 71
   public void processActors(ArrayList<Actor> actors);
   
   // @line: 88
   public ArrayList<Location> getMoveLocations();
   
   // @line: 104
   public Location selectMoveLocation(ArrayList<Location> locs);
   
   // @line: 125
   public void makeMove(Location loc);
   ```
3. Should subclasses of Critter override the getActors method? Explain.
   
   回答：Critter的子类应该要重写`GetActors`方法，因为在子类中重载此方法，可以便在其他地方查找要处理的参与者；如果Critter的子类有不同的获取规则或一些获取条件，它需要被重写来实现子类的要求。
   
   ```java
   // @file: gridworld/actor/Critter.java
   // @line: 50-53
   /*
    * Gets the actors for processing. Implemented to return the actors that
    * occupy neighboring grid locations. Override this method in subclasses to
    * look elsewhere for actors to process.<br />
   */
   ```
4. Describe the way that a critter could process actors.
   
   回答：Critter可以处理 Actors，例如移除它们，改变它们的颜色，位置，方向，或选中一部分Actors做上述操作。
   
   ```java
   // @file: gridworld/actor/Critter.java
   // @line: 62-65
   
   /*
    * Processes the elements of <code>actors</code>. New actors may be added
    * to empty locations. Implemented to "eat" (i.e. remove) selected actors
    * that are not rocks or critters. Override this method in subclasses to
    * process actors in a different way. <br />
    */
   ```
5. What three methods must be invoked to make a critter move? Explain each of these methods.
   
   回答：`getMoveLocations`, `selectMoveLocation`, `makeMove`三个方法是一个 Critter 移动是需要调用的方法。
   
   解释：首先需要通过调用 `getMoveLocations` 方法获取下一步能够移动到的位置组成的数组，然后调用`selectMoveLocation`从 `getMoveLocations` 的返回结果中挑选出移动的目标位置，最后执行`makeMove`将Critter移动到目标位置。
   
   ```java
   // @file: gridworld/actor/Critter.java
   // @line: 88
   public ArrayList<Location> getMoveLocations();
   
   // @line: 104
   public Location selectMoveLocation(ArrayList<Location> locs);
   
   // @line: 125
   public void makeMove(Location loc);
   ```
6. Why is there no Critter constructor?
   
   回答：因为没有必要，Critter继承自Actor类，Actor类含构造函数，在这里，Java也会为Critter提供一个默认构造函数，该构造函数会调用基类Actor的构造函数（通过 `super()`）。默认创建 Critter 时，默认构造函数回为用户创建一个方向朝北的蓝色 Critter。
   
   ```java
   // @file: gridworld/actor/Actor.java
   // @line: 39-45
   public Actor()
   {
       color = Color.BLUE;
       direction = Location.NORTH;
       grid = null;
       location = null;
   }
   ```

### Set 8

The source code for the ChameleonCritter class is in the critters directory

1. Why does act cause a ChameleonCritter to act differently from a Critter even though ChameleonCritter does not override act?
   
   回答：ChameleonCritter没有重写`act`，但执行不同于默认Critter动作的原因是ChameleonCritter重写了`processActors`和`makeMove`，这两个函数被act函数调用了，故导致的运动效果不同。
   
   ```java
   // @file: projects/critter/ChameleonCritter.java
   // @line: 36
   public void processActors(ArrayList<Actor> actors);
   
   // @line: 50
   public void makeMove(Location loc);
   ```
   
   在面向对象语言中，子类调用方法的顺序是有限考虑子类有无重写，若有则使用子类的重写的方法，若无在考虑调用父类提供的方法体。
   
   ChameleonCritter重写了`processActors`：效果为随机选择一个邻居并改变它的颜色为邻居的颜色，它重写的`makeMOve`效果为每次移动都面向下一个位置。
2. Why does the makeMove method of ChameleonCritter call super.makeMove?
   
   回答：这样做的目的是在子类`makeMove`执行时待用父类`makeMove`。
   
   ChameleonCritter 重写的`makeMove`在基类`makeMove`的基础上增加动作（即设置方向），在设置结束后需要调用基类的`makeMove`来移动到下一个位置，故使用`super.`来调用基类的`makeMove`。
   
   相比于拷贝基类`makeMove`的代码，这样写能让代码更简洁。
   
   ```java
   // @file: projects/critter/ChameleonCritter.java
   // @line: 52-53
   setDirection(getLocation().getDirectionToward(loc));
   super.makeMove(loc);
   ```
3. How would you make the ChameleonCritter drop flowers in its old location when it moves?
   
   回答：参考Bug类的`move`方法，修改ChameleonCritter类的`makeMove`方法如下所示：
   
   ```java
   public void makeMove(Location loc){
       Grid<Actor> gr = getGrid();
       if (gr == null)
           return;
       Location oldLoc = getLocation();
       setDirection(getLocation().getDirectionToward(loc));
       super.makeMove(loc);
       // 如果没有实际移动，则不放置Flower
       if(loc.equals(oldLoc)){
           return;
       }
       Flower flower = new Flower(getColor());
       flower.putSelfInGrid(gr, oldLoc);
   }
   ```
4. Why doesn’t ChameleonCritter override the getActors method?
   
   回答：因为变色龙被设计取相邻 Actor 并使自己与相邻 Actor 同颜色，故没有这重写的需求， 父类Critter提供的`getActors`方法满足已经子类的需要（就是获得相邻空间的 Actor 列表）
   
   ```java
   // @file: gridworld/actor/Critter.java
   // @line: 58
   return getGrid().getNeighbors(getLocation());
   ```
5. Which class contains the getLocation method?
   
   回答：Actor类，所有继承了Actor类的子类也会继承该方法。
   
   ```java
   // @file: gridworld/actor/Actor.java
   // @line: 102
   public Location getLocation()；
   ```
   
6. How can a Critter access its own grid?
   
   回答：通过调用Critter的基类 Actor的方法`getGrid`
   
   ```java
   // @file: gridworld/actor/Actor.java
   // @line: 92
   public Grid<Actor> getGrid();
   ```

### Set 9

The source code for the CrabCritter class is reproduced at the end of this part of GridWorld.

1. Why doesn’t CrabCritter override the processActors method?
   
   回答：因为螃蟹被设计为吃掉目标范围的 Flower，所以没有这重写的需求， 父类Critter提供的`processActors`方法已经满足子类的需要（对参数列表中的所有 Actor，如不为 Rock 且不为 Critter，则移除）
   
   ```java
   // @file: gridworld/actor/Critter.java
   // @line: 73-77
   for (Actor a : actors)
   {
       if (!(a instanceof Rock) && !(a instanceof Critter))
           a.removeSelfFromGrid();
   }
   ```
2. Describe the process a CrabCritter uses to find and eat other actors. Does it always eat all neighboring actors? Explain.
   
   回答：
   
   * Crab 执行 `act` 来完成它的动作，首先是调用 `getActors`获取目标范围内的 Actor，然后调用 `processAcors` 来处理这些 Actors，最后选择移动位置（`selectMoveLocation`）并移动（`makeMove`）。CrabCritter重写了`getActors`、`getMoveLocations`和`makeMove`。
   * Crab 寻找并吃掉 Actor 的具体过程如下：首先 Crab 搜寻前方、左边和右边的位置，如果该位置不为空则加入到目标列表中。
     
     ```java
     // @file: projects/critter/CrabCritter.java
     // @line: 47-54
     int[] dirs = { Location.AHEAD, Location.HALF_LEFT, Location.HALF_RIGHT };
     for (Location loc : getLocationsInDirections(dirs))
     {
         Actor a = getGrid().get(loc);
         if (a != null)
             actors.add(a);
     }
     ```
     
     然后从 Grid 中移除目标列表中的 Actors
     
     ```java
     // @file: gridworld/actor/Critter.java
     // @line: 73-77
     for (Actor a : actors)
     {
         if (!(a instanceof Rock) && !(a instanceof Critter))
             a.removeSelfFromGrid();
     }
     ```
   * 显然，Crab 不会吃掉所有相邻的 Actor，因为每次 Crab的目标范围只是方向的左前侧、右前侧和正前方，例如正后方的Actor就不会被吃掉。
     
     ```java
     // @file: projects/critter/CrabCritter.java
     // @line: 47-48
     int[] dirs = { Location.AHEAD, Location.HALF_LEFT, Location.HALF_RIGHT };
     ```
3. Why is the getLocationsInDirections method used in CrabCritter?
   
   回答：来获取合法的相邻位置。方法的参数是一个相对方向数组，方法体遍历该数组，根据这些方向来寻找这个方向下下一个位置合法，并将所有合法位置范围。
   
   * 注：这里的相对方向指相对于 Crab 当前方向的方向，如左右前后；合法指的是不越界。
   
   ```java
   // @file: projects/critter/CrabCritter.java
   // @line: 107-112
   for (int d : directions)
   {
       Location neighborLoc = loc.getAdjacentLocation(getDirection() + d);
       if (gr.isValid(neighborLoc))
           locs.add(neighborLoc);
   }
   ```
   
   在类的实现中有两处用到了该函数，分别用于寻找食物位置和寻找下一个移动位置。
   
   ```java
   // @file: projects/critter/CrabCritter.java
   // @line: 47-49
   int[] dirs = { Location.AHEAD, Location.HALF_LEFT, Location.HALF_RIGHT };
   for (Location loc : getLocationsInDirections(dirs))
   
   // @line: 65-67
   int[] dirs = { Location.LEFT, Location.RIGHT };
   for (Location loc : getLocationsInDirections(dirs))
   ```
4. If a CrabCritter has location (3, 4) and faces south, what are the possible locations for actors that are returned by a call to the getActors method?
   
   回答：(4, 4)、(4, 3)、(4, 5)，分别为前、左前、右前方的位置。
   
   ```java
   // @file: projects/critter/CrabCritter.java
   // @line: 47-48
   int[] dirs = { Location.AHEAD, Location.HALF_LEFT, Location.HALF_RIGHT };
   ```
5. What are the similarities and differences between the movements of a CrabCritter and a Critter?
   
   回答：
   
   * 相同点：
     
     * 移动时不转向
       
       ```java
       // @file: gridworld/actor/Critter.java
       // @line: 130
       moveTo(loc);
       
       // @file: projects/critter/CrabCritter.java
       // @line: 90
       super.makeMove(loc);
       ```
     * 移动位置是随机的：在移动范围内随机选择下一步的方向/位置
       
       ```java
       // @file: gridworld/actor/Critter.java
       // @line: 109-110
       int r = (int) (Math.random() * n);
       return locs.get(r);
       
       // @file: projects/critter/CrabCritter.java
       // @line: 81-87
       double r = Math.random();
       int angle;
       if (r < 0.5)
           angle = Location.LEFT;
       else
           angle = Location.RIGHT;
       setDirection(getDirection() + angle);
       ```
   * 不同点：
     
     * Crab的移动方向受限：只能左右移动，而Critter可以移动到任意一个方向
       
       ```java
       // @file: projects/critter/CrabCritter.java
       // @line: 65-67
       int[] dirs = { Location.LEFT, Location.RIGHT };
       for (Location loc : getLocationsInDirections(dirs))
       
       // @file: gridworld/grid/AbstractGrid.java
       // @line: 41
       for (int i = 0; i < Location.FULL_CIRCLE / Location.HALF_RIGHT; i++)
       ```
     * 在不能移动时，Crab会转向，而Critter不会
       
       ```java
       // @file: projects/critter/CrabCritter.java
       // @line: 79, 87
       if (loc.equals(getLocation())){
           //...
          	setDirection(getDirection() + angle);
       }
       ```
6. How does a CrabCritter determine when it turns instead of moving?
   
   回答：当目标移动位置等当前位置时，Crab选择用转向替代移动。
   
   ```java
   // @file: projects/critter/CrabCritter.java
   // @line: 79, 87
   if (loc.equals(getLocation())){
       //...
      	setDirection(getDirection() + angle);
   }
   ```
7. Why don’t the CrabCritter objects eat each other?
   
   回答：因为 CrabCritter 继承自 Critter，CrabCritter 不会吃掉 Critter，所以 CrabCritter不会吃掉其他 CrabCritter。
   
   ```java
   // @file: gridworld/actor/Critter.java
   // @line: 75-76
   if (!(a instanceof Rock) && !(a instanceof Critter))
       a.removeSelfFromGrid();
   ```