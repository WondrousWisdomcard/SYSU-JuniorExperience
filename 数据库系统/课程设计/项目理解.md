[toc]

## 项目理解

### 项目内容

* **项目内容：多核并行设计 - 基于B+树实现并行化Bulk Loading操作**
  * **并行实现**：
    * 实现叶子节点的并行构建
    * 实现索引节点的并行构建
  * **实验检验**：
    * 写一个遍历查询的函数，遍历输出每一层节点的数据，与串行程序相比，检验程序设计是否正确。
    * 比较不同数据量的并行加速效果，将加速比绘制成折线图。
  * 并行设计过程，**多线程或者多进程同时执行构建不同的节点**，有可能会出现中间的叶子节点数据不满的情况，可能导致叶子节点的数目有变化，可以结合实际情况分析是否正确，或者说这样的情况会有哪些好处或者坏处。

### 提交要求

* 主要代码 + README（如何运行代码，说明参数设置）
* 对B+树Bulk Loading过程的理解（ + 可视化）
* 算法并行的设计思路（ + 可视化）
* **算法流程图**
* **关键代码描述**
* **实验结果和实验分析**
* 性能调优和**创新优化（更底层的IO优化）**
* 实验心得（每个同学一份，统一字数要求）



### 现有资料



* **一份串行实现的B+树Bulk Loading代码**
  * `b_tree.h`  `b_tree.cc` B+树的构建
  * `b_node.h`  `b_node.cc` B+树的节点
  * `block_file.h`  `block_file.cc` 磁盘交互的实现
  * `main.cc` 调用的主程序
  * `pri_queue` `random` `util` `def` 辅助函数
* **数据集**：提供一个有序键值对数据生成的代码文件`make_data.cpp`，自己生成不同数据量大小的数据，测试其并行设计在不同数据量下的加速效果。

### 背景知识

* **B+树的结构**
  * 有 k 个子树的中间节点包含有 k 个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。
  * 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
  * 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。
* **Bulk Loading批量加载**
  * 批量加载是对有序的数据进行批量构建B+树的过程
  * 批量连续插入的过程：自下往上。先从底层叶子节点构建，从左往右按顺序构建一个双向链表；从下往上，一层层构建索引节点，每一层也是从左往右构建索引节点。
  * 节点说明：
    * 叶子节点：从左往右构建一层双向链表（相邻节点之间有互相指向的指针），每个节点有两个数组，一个储存Key，一个储存Value，一个Key对应有16个Value。
    * 索引节点：每一层从左往右根据下一层子结点构建一层双向链表（相邻节点之间有互相指向的指针），每个节点有两个数组，一个存储Key，一个存储指向子节点的指针，二者数量相等。
  * 构建的B+树的每一个节点会依次存储到一个文件的不同区域中，**每一个节点有一个块号**，表示节点存储到文件的区域编号，上述所说的指针实际上是一个块号，表示节点存储在文件的位置。
  * 串行Bulk Loading过程中，从底层往上，每一层从左往右的节点的块号是按顺序分配的；并行执行可能会导致块号不连续，要考虑这种问题怎么解决，否则并行执行会出现错误。

## 代码理解

### BLOCK_FILE

* 块编号的说明：物理上，文件的第一个块储存头信息，数据信息从第二个块才开始储存。
  * ”内部编号“：从 0 开始，考虑储存头信息的块 Block 0，第一个储存数据信息的块为 Block 1，用这种编号方式的变量有`act_block`、`cache_cont`
    * `num_block_`算块总数时就是不考虑储存头信息的块的。
  * ”外部编号“：从 0 开始，第一个储存数据信息的块为 Block 0，用这种编号方式的变量有`pos`、`index`（`write_block`和`read_block`方法用到了）。
    * 我们有`<act_block> = <index> + 1`，例如`index = 1` 时对应 `act_block = 0`

```
Block 0 头节点
block_length num_blocks other_info
Block 1 索引节点
level, num_entries, left_sibling, right_sibling
key[0] key[1] key[2] ... key[num_entries - 1]
son[0] son[1] son[2] ... son[num_entries - 1]
Block 2 叶子节点
level, num_entries, left_sibling, right_sibling
num_keys
key[0], key[1], ..., key[num_keys-1]
id[0], id[1], id[2], ..., id[num_entries-1]
```

``` C++
FILE *fp_;						// 文件指针
char fname_[200];				// 文件名
bool new_flag_;					// 新文件标识

int block_length_;				// 块长度
int act_block_;					// 当前块块号（当前指fp_扫到的地方）
int num_blocks_;				// 块总数
```

``` c++
BlockFile(int b_length, const char *name); 
// 构造函数：块长度为 b_length，文件名为 name
~BlockFile();
// 析构函数

inline void put_bytes(const char *bytes, int num);
// 将一个长度为 num 的字节串 bytes 写入文件
inline void get_bytes(char *bytes, int num);
// 返回文件中下一个长度为 num 的字节串，存放在 bytes 中

inline void seek_block(int bnum);
// 将文件指针右移 bnum 个块（不是字节）

inline bool file_new();
inline int get_blocklength();
inline int get_num_of_blocks();

inline void fwrite_number(int num);
// 将 num 写入文件
inline int fread_number();
// 返回文件中下一个整数

void read_header(char *buffer);
// 读取物理文件中第一个块除了头信息剩下的字节，写到 buffer 中
// 如果物理文件有数据块，则更新 act_block_ （置为1）

void set_header(const char *buffer);
// 将 buffer 的内容写入物理文件中第一个块除了头信息剩下的字节
// 可以是一些注释或说明信息
// 如果物理文件有数据块，则更新 act_block_ （置为1）

bool read_block(Block block, int index);
// 把第 index 个数据块（外部块号）的内容写到 block 中，更新 act_block_
// Block 是 char[] (typedef char Block[];)

bool write_block(Block block, int index);
// 把 block 的内容写到第 index 个数据块中，更新 act_block_
// 写入的数据块必须预先存在

int append_block(Block block);
// 在文件末尾新增一个块，块内容为 block，更新头信息
// 返回外部块号 （num_blocks_ - 1）

bool delete_last_blocks(int num);
// 删除最后 num 个块，更新头信息
// 如果删除成功，返回 true
```

### B_NODE

* 项 Entry
  * 索引项：键值(FLOAT) + 指针(INT) 若干个索引项与一个索引结点对应，键值和指针一一对应
  * 数据项：数据项(VALUE) 一个叶子结点有若干个键值，每个键值最多有16个值 Value 

#### BNode

``` c++
char  level_;					// 可能是以该节点为根的子树的高度
int   num_entries_;				// 项的数目(索引项或数据项)
int   left_sibling_;			// 左兄弟结点在磁盘中的地址
int   right_sibling_;			// 右兄弟节点在磁盘中的地址
float *key_;					// 键值数组

bool  dirty_;					// 脏位
int   block_;					// 结点地址所在的块号(外部块号)
int   capacity_;				// 项的最大数量
BTree *btree_;					// 以该节点为根的子树
```

```c++
BNode();
virtual ~BNode();

virtual void init(int level, BTree *btree);
virtual void init_restore(BTree *btree, int block);

virtual void read_from_buffer(const char *buf);
virtual void write_to_buffer(char *buf);
virtual inline int get_entry_size();
virtual int find_position_by_key(float key);
virtual inline float get_key(int index);
    
virtual BNode* get_left_sibling();
virtual BNode* get_right_sibling();

inline int get_block();
inline int get_num_entries();
inline int get_level();

inline int get_header_size();
// "Header"由 level, num_entries, left_sibling, right_slibing组成\
// 故其大小为: SIZECHAR + SIZEINT + SIZEINT + SIZEINT

inline float get_key_of_node();

inline bool isFull();
// 判断条件是当前项的数目(num_entries)是否等于项的最大数量(capacity)

inline void set_left_sibling(int left_sibling);
inline void set_right_sibling(int right_sibling);
```

#### BIndexNode

``` c++
int *son_;							// 指向子节点的数组,数组长度等于key_
```

``` c++
int get_entry_size(); 				// 索引项的大小 = (FLOAT)键值 + (INT)指针
int find_position_by_key(float key);// 找到刚好 <= 输入 key 的在 key_ 中的位置
float get_key(int index); 			// key_[index]
int get_son(int index);				// son_[index] key 和 son 是一一对应的
```

``` c++
BIndexNode();
~BIndexNode();
// 析构函数: 如果脏位 = true, 则需要写入磁盘

void init(int level, BTree *btree);
// capacity_ = (b_length - get_header_size()) / get_entry_size();
// 索引项的数目 = (块长度 - 索引节点头信息长度) / 索引项大小 
// 据此可以看到一个索引节点占一个块, 要求索引项数目需要大于等于50
// 该方法会在BLOCK_FILE文件末尾插入一个新块

void init_restore(BTree *btree,	int block);
// 根据一个已存在的btree创建一个索引节点
// 根据块号读取块内的内容,然后在通过 read_from_buffer 提取出来

void read_from_buffer(const char *buf);
// 从字符串buf中读取一个索引节点的信息,包括:
// level, num_entries, left_sibling, right_sibling
// 再根据 num_entries 读取 key[] 和 son[]

void write_to_buffer(char *buf);
// read_from_buffer 的逆过程, 将索引节点的信息写入缓冲区buf

BIndexNode* get_left_sibling();
BIndexNode* get_right_sibling();

void add_new_child(float key, int son);
// 直接加在最后面了(默认它们是有序的吧)
```

#### BLeafNode

``` c++
int num_keys_;					// 键的数量
int *id_;						// 值的数组
int capacity_keys_;				// 键的最大数量
//int   num_entries_;			// 数据项的总数
//int   capacity_;				// 数据项的最大数量
```

``` c++
int get_entry_size(); 				// 数据项的大小 = SIZEINT
int find_position_by_key(float key);// 找到刚好 <= 输入 key 的在 key_ 中的位置
float get_key(int index); 			// key_[index] (index < num_keys_)

int get_key_size(int block_length);
// 这应该是一个叶子节点键值所占的空间
// 键的最大数量 capacity_keys_ = block_length / LEAF_NODE_SIZE
// 返回 键的最大数量 * 一个键的长度 + 记录键的数目的整形(num_keys_)
// 返回 capacity_keys_ * SIZEFLOAT + SIZEINT;

int get_increment();
// 返回 LEAF_NODE_SIZE / get_entry_size() = 16
// 应该是一个键所对应的值的数量

int get_num_keys();
int get_entry_id(int index2);		// id_[index2] (index2 < num_entries_)
```

```c++
BIndexNode();
~BIndexNode();
// 析构函数: 如果脏位 = true, 则需要写入磁盘

void init(int level, BTree *btree);
// capacity_ = (b_length - header_size - key_size) / entry_size;
// 据此可以看到一个叶子节点占一个块, 要求数据项数目需要大于等于100
// 一个叶子结点的内容: header + 叶子节点的"header"(也就是键数组+键数目) + 值数组
void init_restore(BTree *btree,	int block);

void read_from_buffer(const char *buf);
void write_to_buffer(char *buf);
// 可以看到叶子节点在文件中储存的内容格式
// level, num_entries, left_sibling, right_sibling
// num_keys
// key[0], key[1], ..., key[num_keys-1]
// id[0], id[1], id[2], ..., id[num_entries-1]

BIndexNode* get_left_sibling();
BIndexNode* get_right_sibling();

void add_new_child(int id, float key);
// 更新 id[] 和 num_entries
// 如果当前最后一个键的对应的value已满16个,则创建一个新的键值(key)
```

### B_TREE

```c++
int root_;						// 根节点在磁盘中的地址(外部块号)
BNode *root_ptr_;				// 根节点的指针
BlockFile *file_;				// 磁盘文件
```

```c++
BTree();	 
~BTree(); 
// 析构函数: 
//		write_header(header); 
//		file_->set_header(header);

void init(int b_length, const char *fname); 
// 初始化: 新建一棵B+树
//		file_ = new BlockFile(b_length, fname)
//		root_ptr_ = new BIndexNode();
//		root_ptr_->init(0, this);
//  	root_ = root_ptr_->get_block();
//		delete root_ptr_;

void init_restore(const char *fname);
// 初始化: 载入一棵B+树
//		file_ = new BlockFile(0, fname);
//		file_->read_header(header); // 读取剩下的头节点信息
//		read_header(header);

inline int read_header(const char *buf);
// 把buf的内容复制到root中
inline int write_header(char *buf);
// 把root的内容写到buf中

void load_root();
// 根据块号重新载入B+树的根节点

void delete_root(); 
// delete 根节点
```

```c++
int BTree::bulkload(int n, const Result *table){ //从内存中批量加载一棵树 n为数据项总数
    //struct Result { float key_; int id_; };

	BIndexNode *index_child   = NULL;
	BIndexNode *index_prev_nd = NULL;
	BIndexNode *index_act_nd  = NULL;
	BLeafNode  *leaf_child    = NULL;
	BLeafNode  *leaf_prev_nd  = NULL;
	BLeafNode  *leaf_act_nd   = NULL;

	int   id    = -1;
	int   block = -1;
	float key   = MINREAL;

	// -------------------------------------------------------------------------
	//  Level 0 通过 table 构建一层叶子节点
	// -------------------------------------------------------------------------
	bool first_node  = true;		// determine relationship of sibling
	int  start_block = 0;			// position of first node
	int  end_block   = 0;			// position of last node

	for (int i = 0; i < n; ++i) {
		id  = table[i].id_;
		key = table[i].key_;

		if (!leaf_act_nd) { // 如果 act node 为空
			leaf_act_nd = new BLeafNode();
			leaf_act_nd->init(0, this);

			if (first_node) { // 如果为第一个叶子节点,无需设置左兄弟节点,并获取外部块号
				first_node  = false;
				start_block = leaf_act_nd->get_block();
			}
			else {
                // 设置 act node 的左节点为上一个节点 prev node
                // 设置 prev node 的右节点为当前节点 act node 
                // 注:块号与节点一一对应
				leaf_act_nd->set_left_sibling(leaf_prev_nd->get_block());
				leaf_prev_nd->set_right_sibling(leaf_act_nd->get_block());

				delete leaf_prev_nd; leaf_prev_nd = NULL;
			}
            // end_block 最终为最后一个叶子节点的外部块号
			end_block = leaf_act_nd->get_block();
		}	
        
        // 为叶子节点添加数据项, 直到不能再添加
		leaf_act_nd->add_new_child(id, key); 
		if (leaf_act_nd->isFull()) {
            // 一旦一个叶子节点的数据项加满, 进入下一个叶子结点的生成
			leaf_prev_nd = leaf_act_nd;
			leaf_act_nd  = NULL;
		}
	}
	if (leaf_prev_nd != NULL) {
		delete leaf_prev_nd; leaf_prev_nd = NULL;
	}
	if (leaf_act_nd != NULL) {
		delete leaf_act_nd; leaf_act_nd = NULL;
	}

	// -------------------------------------------------------------------------
	// Level 1+ 由下往上生成子节点
    // 终止条件: lastEndBlock == lastStartBlock (only one node, as root)
	// -------------------------------------------------------------------------
	int current_level    = 1;		// current level (leaf level is 0)
	int last_start_block = start_block;	// build b-tree level by level
	int last_end_block   = end_block;	// build b-tree level by level

	while (last_end_block > last_start_block) {
		first_node = true;
		for (int i = last_start_block; i <= last_end_block; ++i) {
			block = i;
			if (current_level == 1) { // 连接叶子节点的一层索引节点
                // 重新载入叶子节点, 并获取其键值(最小的那个)
				leaf_child = new BLeafNode();
				leaf_child->init_restore(this, block); 
				key = leaf_child->get_key_of_node();
				delete leaf_child; leaf_child = NULL;
			}
			else {
                // 重新载入下层索引节点, 并获取其键值(最小的那个)
				index_child = new BIndexNode();
				index_child->init_restore(this, block);
				key = index_child->get_key_of_node();
				delete index_child; index_child = NULL;
			}
            
			if (!index_act_nd) { // 如果 act node 为空, 创建索引节点
				index_act_nd = new BIndexNode();
				index_act_nd->init(current_level, this);

				if (first_node) { // 如果为该层第一个索引节点 记录 start_block
					first_node = false;
					start_block = index_act_nd->get_block();
				}
				else {
                    // 双向连接起来
					index_act_nd->set_left_sibling(index_prev_nd->get_block());
					index_prev_nd->set_right_sibling(index_act_nd->get_block());

					delete index_prev_nd; index_prev_nd = NULL;
				}
                // 记录该层最后一个索引节点 end_block
				end_block = index_act_nd->get_block();
			}					
            // 插入索引项直到插满, 进入下一个索引结点的生成
			index_act_nd->add_new_child(key, block);
			if (index_act_nd->isFull()) {
				index_prev_nd = index_act_nd;
				index_act_nd = NULL;
			}
		}
		if (index_prev_nd != NULL) {// release the space
			delete index_prev_nd; index_prev_nd = NULL;
		}
		if (index_act_nd != NULL) {
			delete index_act_nd; index_act_nd = NULL;
		}
		
		last_start_block = start_block;// update info
		last_end_block = end_block;	// build b-tree of higher level
		++current_level;
	}
	root_ = last_start_block;		// update the <root>

	if (index_prev_nd != NULL) delete index_prev_nd; 
	if (index_act_nd  != NULL) delete index_act_nd;
	if (index_child   != NULL) delete index_child;
	if (leaf_prev_nd  != NULL) delete leaf_prev_nd; 
	if (leaf_act_nd   != NULL) delete leaf_act_nd; 	
	if (leaf_child    != NULL) delete leaf_child; 

	return 0;
}
```

> ### 叶子区
>
> 串行地创建空的叶子节点 获取块号
>
> 大体思路：串行分配块，并行写输入入块
>
> 设 n 个数据项，每个叶子节点 k(capacity) 个数据
>
> 叶子节点 m = \leftceil n / k \rightceil 个
>
> 一个循环 init 申请 m 个块 （分配这个步骤有优化空间）
>
> 假设第一个块号是 a
>
> 
>
> pthread_create 申请多个线程，每个线程 
>
> 顺便把他们串起来
>
> batchload(int blockIndex, Result* tabel, int start, int len)
>
> 里头执行 add_new_child
>
> pthread_join
>
> ### 索引区
>
> k 层
>
> 我们有k-1层的块号数组a, len(a)  = m
>
> 分配 ceil (capacity / m) 个块
>
> pthread_create 申请多个线程，每个线程
>
> loadIndexChild(int blockIndex, int* a, int start, int len)
>
> 里头执行 add_new_child
>
> pthread_join





* 一层申请的块号`int *block`，长度为`len`

* 封装块号申请函数 `int* alloc_blocks(int num);`

* 叶子节点线程函数 `void batchload_leaf(int* start_block, int block_num, Result* start_data, int data_num)`
  * 即该线程处理从开始地址 start_block 处的 block_num 个块，写入的数据为从 start_data 的 data_num 个数据
* 索引节点线程函数 `void batchload_index(int* start_block, int block_num, int * last_start_block, int last_block_num)`
  * 即该线程处理从开始地址 start_block 处的 block_num 个块，处理的数据为从 last_start_block 的 last_block_num 个块



* 写入过程：写内存的过程并行，写硬盘的过程使用一个全局的锁保证一次只有一个锁执行IO写

  * 方法2：生产者-消费者：生产者写内存，消费者写硬盘 **无锁**
  * 方法1：每一个线程在内存中修改完一个块之后，有两种选择：（请求IO的力度(依次IO的速度)）**一个I/O全局锁**

    * 直到获取到锁，才把当前修改的块写到硬盘上，写完后在内存上修改下一个块，否则忙等待
  * 尝试获取锁，如果成功了就写出去修改，如果没成功，就继续修改下一个块（每个块都有个标示位标识是否写成功）。
    * IO力度问题：

      * 内存写好 n 个块就争取锁写，一次写 n 个块到文件
  * 每内存写好一个块就争取锁写，一次写一个块到文件
      * **一旦获得锁就写所有内存写好的块**




## 任务安排

**第一周**

* 基本的代码（三个函数） lxj zyw

* 测试的代码（正确性 + 性能比）改 main 函数 hj 

* B+树的理解 zyw整合一下

* 算法并行的设计思路  hhj

* 算法流程图 hhj 

* DDL 25号晚

**第二周**

zyw：README + 整理 + 写报告

hhj：测试代码 + 运行脚本

jy：实现结果和实验分析代码 + 性能调优和创新优化报告

hj: 算法流程图和可视化的思路 + 代码润色

cjx: 修改报告

> 代码润色：标注我们修改的代码，增加必要的注释
>
> 可视化：py matplotlib

